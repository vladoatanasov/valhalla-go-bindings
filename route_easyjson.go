// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package valhalla

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings(in *jlexer.Lexer, out *ValhallaError) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "error_code":
			out.ErrorCode = int(in.Int())
		case "error":
			out.Error = string(in.String())
		case "status_code":
			out.StatusCode = int(in.Int())
		case "status":
			out.Status = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings(out *jwriter.Writer, in ValhallaError) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"error_code\":"
		out.RawString(prefix[1:])
		out.Int(int(in.ErrorCode))
	}
	{
		const prefix string = ",\"error\":"
		out.RawString(prefix)
		out.String(string(in.Error))
	}
	{
		const prefix string = ",\"status_code\":"
		out.RawString(prefix)
		out.Int(int(in.StatusCode))
	}
	{
		const prefix string = ",\"status\":"
		out.RawString(prefix)
		out.String(string(in.Status))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v ValhallaError) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ValhallaError) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ValhallaError) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ValhallaError) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings(l, v)
}
func easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings1(in *jlexer.Lexer, out *RouteResponse) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "id":
			out.ID = string(in.String())
		case "trip":
			easyjson44127895Decode(in, &out.Trip)
		case "alternates":
			if in.IsNull() {
				in.Skip()
				out.Alternates = nil
			} else {
				in.Delim('[')
				if out.Alternates == nil {
					if !in.IsDelim(']') {
						out.Alternates = make([]RouteResponse, 0, 0)
					} else {
						out.Alternates = []RouteResponse{}
					}
				} else {
					out.Alternates = (out.Alternates)[:0]
				}
				for !in.IsDelim(']') {
					var v1 RouteResponse
					(v1).UnmarshalEasyJSON(in)
					out.Alternates = append(out.Alternates, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings1(out *jwriter.Writer, in RouteResponse) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"id\":"
		out.RawString(prefix[1:])
		out.String(string(in.ID))
	}
	{
		const prefix string = ",\"trip\":"
		out.RawString(prefix)
		easyjson44127895Encode(out, in.Trip)
	}
	{
		const prefix string = ",\"alternates\":"
		out.RawString(prefix)
		if in.Alternates == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.Alternates {
				if v2 > 0 {
					out.RawByte(',')
				}
				(v3).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RouteResponse) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RouteResponse) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RouteResponse) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RouteResponse) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings1(l, v)
}
func easyjson44127895Decode(in *jlexer.Lexer, out *struct {
	Language      string `json:"language"`
	Status        int    `json:"status"`
	Units         string `json:"units"`
	StatusMessage string `json:"status_message"`
	Legs          []struct {
		Shape   string `json:"shape"`
		Summary struct {
			MaxLon float64 `json:"max_lon"`
			MaxLat float64 `json:"max_lat"`
			Time   float64 `json:"time"`
			Length float64 `json:"length"`
			MinLat float64 `json:"min_lat"`
			MinLon float64 `json:"min_lon"`
		} `json:"summary"`
		Maneuvers []Maneuver `json:"maneuvers"`
	} `json:"legs"`
	Summary struct {
		MaxLon float64 `json:"max_lon"`
		MaxLat float64 `json:"max_lat"`
		Time   float64 `json:"time"`
		Length float64 `json:"length"`
		MinLat float64 `json:"min_lat"`
		MinLon float64 `json:"min_lon"`
	} `json:"summary"`
	Locations []struct {
		OriginalIndex int     `json:"original_index"`
		Type          string  `json:"type"`
		Lon           float64 `json:"lon"`
		Lat           float64 `json:"lat"`
		SideOfStreet  string  `json:"side_of_street"`
	} `json:"locations"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "language":
			out.Language = string(in.String())
		case "status":
			out.Status = int(in.Int())
		case "units":
			out.Units = string(in.String())
		case "status_message":
			out.StatusMessage = string(in.String())
		case "legs":
			if in.IsNull() {
				in.Skip()
				out.Legs = nil
			} else {
				in.Delim('[')
				if out.Legs == nil {
					if !in.IsDelim(']') {
						out.Legs = make([]struct {
							Shape   string `json:"shape"`
							Summary struct {
								MaxLon float64 `json:"max_lon"`
								MaxLat float64 `json:"max_lat"`
								Time   float64 `json:"time"`
								Length float64 `json:"length"`
								MinLat float64 `json:"min_lat"`
								MinLon float64 `json:"min_lon"`
							} `json:"summary"`
							Maneuvers []Maneuver `json:"maneuvers"`
						}, 0, 0)
					} else {
						out.Legs = []struct {
							Shape   string `json:"shape"`
							Summary struct {
								MaxLon float64 `json:"max_lon"`
								MaxLat float64 `json:"max_lat"`
								Time   float64 `json:"time"`
								Length float64 `json:"length"`
								MinLat float64 `json:"min_lat"`
								MinLon float64 `json:"min_lon"`
							} `json:"summary"`
							Maneuvers []Maneuver `json:"maneuvers"`
						}{}
					}
				} else {
					out.Legs = (out.Legs)[:0]
				}
				for !in.IsDelim(']') {
					var v4 struct {
						Shape   string `json:"shape"`
						Summary struct {
							MaxLon float64 `json:"max_lon"`
							MaxLat float64 `json:"max_lat"`
							Time   float64 `json:"time"`
							Length float64 `json:"length"`
							MinLat float64 `json:"min_lat"`
							MinLon float64 `json:"min_lon"`
						} `json:"summary"`
						Maneuvers []Maneuver `json:"maneuvers"`
					}
					easyjson44127895Decode1(in, &v4)
					out.Legs = append(out.Legs, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "summary":
			easyjson44127895Decode2(in, &out.Summary)
		case "locations":
			if in.IsNull() {
				in.Skip()
				out.Locations = nil
			} else {
				in.Delim('[')
				if out.Locations == nil {
					if !in.IsDelim(']') {
						out.Locations = make([]struct {
							OriginalIndex int     `json:"original_index"`
							Type          string  `json:"type"`
							Lon           float64 `json:"lon"`
							Lat           float64 `json:"lat"`
							SideOfStreet  string  `json:"side_of_street"`
						}, 0, 1)
					} else {
						out.Locations = []struct {
							OriginalIndex int     `json:"original_index"`
							Type          string  `json:"type"`
							Lon           float64 `json:"lon"`
							Lat           float64 `json:"lat"`
							SideOfStreet  string  `json:"side_of_street"`
						}{}
					}
				} else {
					out.Locations = (out.Locations)[:0]
				}
				for !in.IsDelim(']') {
					var v5 struct {
						OriginalIndex int     `json:"original_index"`
						Type          string  `json:"type"`
						Lon           float64 `json:"lon"`
						Lat           float64 `json:"lat"`
						SideOfStreet  string  `json:"side_of_street"`
					}
					easyjson44127895Decode3(in, &v5)
					out.Locations = append(out.Locations, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode(out *jwriter.Writer, in struct {
	Language      string `json:"language"`
	Status        int    `json:"status"`
	Units         string `json:"units"`
	StatusMessage string `json:"status_message"`
	Legs          []struct {
		Shape   string `json:"shape"`
		Summary struct {
			MaxLon float64 `json:"max_lon"`
			MaxLat float64 `json:"max_lat"`
			Time   float64 `json:"time"`
			Length float64 `json:"length"`
			MinLat float64 `json:"min_lat"`
			MinLon float64 `json:"min_lon"`
		} `json:"summary"`
		Maneuvers []Maneuver `json:"maneuvers"`
	} `json:"legs"`
	Summary struct {
		MaxLon float64 `json:"max_lon"`
		MaxLat float64 `json:"max_lat"`
		Time   float64 `json:"time"`
		Length float64 `json:"length"`
		MinLat float64 `json:"min_lat"`
		MinLon float64 `json:"min_lon"`
	} `json:"summary"`
	Locations []struct {
		OriginalIndex int     `json:"original_index"`
		Type          string  `json:"type"`
		Lon           float64 `json:"lon"`
		Lat           float64 `json:"lat"`
		SideOfStreet  string  `json:"side_of_street"`
	} `json:"locations"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"language\":"
		out.RawString(prefix[1:])
		out.String(string(in.Language))
	}
	{
		const prefix string = ",\"status\":"
		out.RawString(prefix)
		out.Int(int(in.Status))
	}
	{
		const prefix string = ",\"units\":"
		out.RawString(prefix)
		out.String(string(in.Units))
	}
	{
		const prefix string = ",\"status_message\":"
		out.RawString(prefix)
		out.String(string(in.StatusMessage))
	}
	{
		const prefix string = ",\"legs\":"
		out.RawString(prefix)
		if in.Legs == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v6, v7 := range in.Legs {
				if v6 > 0 {
					out.RawByte(',')
				}
				easyjson44127895Encode1(out, v7)
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"summary\":"
		out.RawString(prefix)
		easyjson44127895Encode2(out, in.Summary)
	}
	{
		const prefix string = ",\"locations\":"
		out.RawString(prefix)
		if in.Locations == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Locations {
				if v8 > 0 {
					out.RawByte(',')
				}
				easyjson44127895Encode3(out, v9)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson44127895Decode3(in *jlexer.Lexer, out *struct {
	OriginalIndex int     `json:"original_index"`
	Type          string  `json:"type"`
	Lon           float64 `json:"lon"`
	Lat           float64 `json:"lat"`
	SideOfStreet  string  `json:"side_of_street"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "original_index":
			out.OriginalIndex = int(in.Int())
		case "type":
			out.Type = string(in.String())
		case "lon":
			out.Lon = float64(in.Float64())
		case "lat":
			out.Lat = float64(in.Float64())
		case "side_of_street":
			out.SideOfStreet = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode3(out *jwriter.Writer, in struct {
	OriginalIndex int     `json:"original_index"`
	Type          string  `json:"type"`
	Lon           float64 `json:"lon"`
	Lat           float64 `json:"lat"`
	SideOfStreet  string  `json:"side_of_street"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"original_index\":"
		out.RawString(prefix[1:])
		out.Int(int(in.OriginalIndex))
	}
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.String(string(in.Type))
	}
	{
		const prefix string = ",\"lon\":"
		out.RawString(prefix)
		out.Float64(float64(in.Lon))
	}
	{
		const prefix string = ",\"lat\":"
		out.RawString(prefix)
		out.Float64(float64(in.Lat))
	}
	{
		const prefix string = ",\"side_of_street\":"
		out.RawString(prefix)
		out.String(string(in.SideOfStreet))
	}
	out.RawByte('}')
}
func easyjson44127895Decode2(in *jlexer.Lexer, out *struct {
	MaxLon float64 `json:"max_lon"`
	MaxLat float64 `json:"max_lat"`
	Time   float64 `json:"time"`
	Length float64 `json:"length"`
	MinLat float64 `json:"min_lat"`
	MinLon float64 `json:"min_lon"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "max_lon":
			out.MaxLon = float64(in.Float64())
		case "max_lat":
			out.MaxLat = float64(in.Float64())
		case "time":
			out.Time = float64(in.Float64())
		case "length":
			out.Length = float64(in.Float64())
		case "min_lat":
			out.MinLat = float64(in.Float64())
		case "min_lon":
			out.MinLon = float64(in.Float64())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode2(out *jwriter.Writer, in struct {
	MaxLon float64 `json:"max_lon"`
	MaxLat float64 `json:"max_lat"`
	Time   float64 `json:"time"`
	Length float64 `json:"length"`
	MinLat float64 `json:"min_lat"`
	MinLon float64 `json:"min_lon"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"max_lon\":"
		out.RawString(prefix[1:])
		out.Float64(float64(in.MaxLon))
	}
	{
		const prefix string = ",\"max_lat\":"
		out.RawString(prefix)
		out.Float64(float64(in.MaxLat))
	}
	{
		const prefix string = ",\"time\":"
		out.RawString(prefix)
		out.Float64(float64(in.Time))
	}
	{
		const prefix string = ",\"length\":"
		out.RawString(prefix)
		out.Float64(float64(in.Length))
	}
	{
		const prefix string = ",\"min_lat\":"
		out.RawString(prefix)
		out.Float64(float64(in.MinLat))
	}
	{
		const prefix string = ",\"min_lon\":"
		out.RawString(prefix)
		out.Float64(float64(in.MinLon))
	}
	out.RawByte('}')
}
func easyjson44127895Decode1(in *jlexer.Lexer, out *struct {
	Shape   string `json:"shape"`
	Summary struct {
		MaxLon float64 `json:"max_lon"`
		MaxLat float64 `json:"max_lat"`
		Time   float64 `json:"time"`
		Length float64 `json:"length"`
		MinLat float64 `json:"min_lat"`
		MinLon float64 `json:"min_lon"`
	} `json:"summary"`
	Maneuvers []Maneuver `json:"maneuvers"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "shape":
			out.Shape = string(in.String())
		case "summary":
			easyjson44127895Decode2(in, &out.Summary)
		case "maneuvers":
			if in.IsNull() {
				in.Skip()
				out.Maneuvers = nil
			} else {
				in.Delim('[')
				if out.Maneuvers == nil {
					if !in.IsDelim(']') {
						out.Maneuvers = make([]Maneuver, 0, 0)
					} else {
						out.Maneuvers = []Maneuver{}
					}
				} else {
					out.Maneuvers = (out.Maneuvers)[:0]
				}
				for !in.IsDelim(']') {
					var v10 Maneuver
					(v10).UnmarshalEasyJSON(in)
					out.Maneuvers = append(out.Maneuvers, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode1(out *jwriter.Writer, in struct {
	Shape   string `json:"shape"`
	Summary struct {
		MaxLon float64 `json:"max_lon"`
		MaxLat float64 `json:"max_lat"`
		Time   float64 `json:"time"`
		Length float64 `json:"length"`
		MinLat float64 `json:"min_lat"`
		MinLon float64 `json:"min_lon"`
	} `json:"summary"`
	Maneuvers []Maneuver `json:"maneuvers"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"shape\":"
		out.RawString(prefix[1:])
		out.String(string(in.Shape))
	}
	{
		const prefix string = ",\"summary\":"
		out.RawString(prefix)
		easyjson44127895Encode2(out, in.Summary)
	}
	{
		const prefix string = ",\"maneuvers\":"
		out.RawString(prefix)
		if in.Maneuvers == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v11, v12 := range in.Maneuvers {
				if v11 > 0 {
					out.RawByte(',')
				}
				(v12).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings2(in *jlexer.Lexer, out *RouteRequest) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "locations":
			if in.IsNull() {
				in.Skip()
				out.Locations = nil
			} else {
				in.Delim('[')
				if out.Locations == nil {
					if !in.IsDelim(']') {
						out.Locations = make([]Location, 0, 0)
					} else {
						out.Locations = []Location{}
					}
				} else {
					out.Locations = (out.Locations)[:0]
				}
				for !in.IsDelim(']') {
					var v13 Location
					(v13).UnmarshalEasyJSON(in)
					out.Locations = append(out.Locations, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "costing":
			out.Costing = string(in.String())
		case "directions_options":
			(out.DirectionsOptions).UnmarshalEasyJSON(in)
		case "id":
			out.ID = string(in.String())
		case "costing_options":
			(out.CostingOptions).UnmarshalEasyJSON(in)
		case "avoid_locations":
			if in.IsNull() {
				in.Skip()
				out.AvoidLocations = nil
			} else {
				in.Delim('[')
				if out.AvoidLocations == nil {
					if !in.IsDelim(']') {
						out.AvoidLocations = make([]Location, 0, 0)
					} else {
						out.AvoidLocations = []Location{}
					}
				} else {
					out.AvoidLocations = (out.AvoidLocations)[:0]
				}
				for !in.IsDelim(']') {
					var v14 Location
					(v14).UnmarshalEasyJSON(in)
					out.AvoidLocations = append(out.AvoidLocations, v14)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "verbose":
			out.Verbose = bool(in.Bool())
		case "contours":
			if in.IsNull() {
				in.Skip()
				out.Contours = nil
			} else {
				in.Delim('[')
				if out.Contours == nil {
					if !in.IsDelim(']') {
						out.Contours = make([]Contour, 0, 2)
					} else {
						out.Contours = []Contour{}
					}
				} else {
					out.Contours = (out.Contours)[:0]
				}
				for !in.IsDelim(']') {
					var v15 Contour
					(v15).UnmarshalEasyJSON(in)
					out.Contours = append(out.Contours, v15)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "polygons":
			out.Polygons = bool(in.Bool())
		case "denoise":
			out.Denoise = float32(in.Float32())
		case "generalize":
			out.Generalize = float32(in.Float32())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings2(out *jwriter.Writer, in RouteRequest) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Locations) != 0 {
		const prefix string = ",\"locations\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v16, v17 := range in.Locations {
				if v16 > 0 {
					out.RawByte(',')
				}
				(v17).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if in.Costing != "" {
		const prefix string = ",\"costing\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Costing))
	}
	if true {
		const prefix string = ",\"directions_options\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.DirectionsOptions).MarshalEasyJSON(out)
	}
	if in.ID != "" {
		const prefix string = ",\"id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.ID))
	}
	if true {
		const prefix string = ",\"costing_options\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.CostingOptions).MarshalEasyJSON(out)
	}
	if len(in.AvoidLocations) != 0 {
		const prefix string = ",\"avoid_locations\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v18, v19 := range in.AvoidLocations {
				if v18 > 0 {
					out.RawByte(',')
				}
				(v19).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if in.Verbose {
		const prefix string = ",\"verbose\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Verbose))
	}
	if len(in.Contours) != 0 {
		const prefix string = ",\"contours\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v20, v21 := range in.Contours {
				if v20 > 0 {
					out.RawByte(',')
				}
				(v21).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if in.Polygons {
		const prefix string = ",\"polygons\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Bool(bool(in.Polygons))
	}
	if in.Denoise != 0 {
		const prefix string = ",\"denoise\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float32(float32(in.Denoise))
	}
	if in.Generalize != 0 {
		const prefix string = ",\"generalize\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Float32(float32(in.Generalize))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RouteRequest) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RouteRequest) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RouteRequest) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RouteRequest) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings2(l, v)
}
func easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings3(in *jlexer.Lexer, out *Maneuver) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "travel_mode":
			out.TravelMode = string(in.String())
		case "begin_shape_index":
			out.BeginShapeIndex = int(in.Int())
		case "length":
			out.Length = float64(in.Float64())
		case "time":
			out.Time = float64(in.Float64())
		case "type":
			out.Type = int(in.Int())
		case "end_shape_index":
			out.EndShapeIndex = int(in.Int())
		case "instruction":
			out.Instruction = string(in.String())
		case "verbal_pre_transition_instruction":
			out.VerbalPreTransitionInstruction = string(in.String())
		case "travel_type":
			out.TravelType = string(in.String())
		case "street_names":
			if in.IsNull() {
				in.Skip()
				out.StreetNames = nil
			} else {
				in.Delim('[')
				if out.StreetNames == nil {
					if !in.IsDelim(']') {
						out.StreetNames = make([]string, 0, 4)
					} else {
						out.StreetNames = []string{}
					}
				} else {
					out.StreetNames = (out.StreetNames)[:0]
				}
				for !in.IsDelim(']') {
					var v22 string
					v22 = string(in.String())
					out.StreetNames = append(out.StreetNames, v22)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "verbal_transition_alert_instruction":
			out.VerbalTransitionAlertInstruction = string(in.String())
		case "verbal_post_transition_instruction":
			out.VerbalPostTransitionInstruction = string(in.String())
		case "sign":
			easyjson44127895Decode4(in, &out.Sign)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings3(out *jwriter.Writer, in Maneuver) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"travel_mode\":"
		out.RawString(prefix[1:])
		out.String(string(in.TravelMode))
	}
	{
		const prefix string = ",\"begin_shape_index\":"
		out.RawString(prefix)
		out.Int(int(in.BeginShapeIndex))
	}
	{
		const prefix string = ",\"length\":"
		out.RawString(prefix)
		out.Float64(float64(in.Length))
	}
	{
		const prefix string = ",\"time\":"
		out.RawString(prefix)
		out.Float64(float64(in.Time))
	}
	{
		const prefix string = ",\"type\":"
		out.RawString(prefix)
		out.Int(int(in.Type))
	}
	{
		const prefix string = ",\"end_shape_index\":"
		out.RawString(prefix)
		out.Int(int(in.EndShapeIndex))
	}
	{
		const prefix string = ",\"instruction\":"
		out.RawString(prefix)
		out.String(string(in.Instruction))
	}
	{
		const prefix string = ",\"verbal_pre_transition_instruction\":"
		out.RawString(prefix)
		out.String(string(in.VerbalPreTransitionInstruction))
	}
	{
		const prefix string = ",\"travel_type\":"
		out.RawString(prefix)
		out.String(string(in.TravelType))
	}
	if len(in.StreetNames) != 0 {
		const prefix string = ",\"street_names\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v23, v24 := range in.StreetNames {
				if v23 > 0 {
					out.RawByte(',')
				}
				out.String(string(v24))
			}
			out.RawByte(']')
		}
	}
	if in.VerbalTransitionAlertInstruction != "" {
		const prefix string = ",\"verbal_transition_alert_instruction\":"
		out.RawString(prefix)
		out.String(string(in.VerbalTransitionAlertInstruction))
	}
	if in.VerbalPostTransitionInstruction != "" {
		const prefix string = ",\"verbal_post_transition_instruction\":"
		out.RawString(prefix)
		out.String(string(in.VerbalPostTransitionInstruction))
	}
	if true {
		const prefix string = ",\"sign\":"
		out.RawString(prefix)
		easyjson44127895Encode4(out, in.Sign)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Maneuver) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Maneuver) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Maneuver) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Maneuver) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings3(l, v)
}
func easyjson44127895Decode4(in *jlexer.Lexer, out *struct {
	ExitBranchElements []struct {
		Text string `json:"text"`
	} `json:"exit_branch_elements"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "exit_branch_elements":
			if in.IsNull() {
				in.Skip()
				out.ExitBranchElements = nil
			} else {
				in.Delim('[')
				if out.ExitBranchElements == nil {
					if !in.IsDelim(']') {
						out.ExitBranchElements = make([]struct {
							Text string `json:"text"`
						}, 0, 4)
					} else {
						out.ExitBranchElements = []struct {
							Text string `json:"text"`
						}{}
					}
				} else {
					out.ExitBranchElements = (out.ExitBranchElements)[:0]
				}
				for !in.IsDelim(']') {
					var v25 struct {
						Text string `json:"text"`
					}
					easyjson44127895Decode5(in, &v25)
					out.ExitBranchElements = append(out.ExitBranchElements, v25)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode4(out *jwriter.Writer, in struct {
	ExitBranchElements []struct {
		Text string `json:"text"`
	} `json:"exit_branch_elements"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"exit_branch_elements\":"
		out.RawString(prefix[1:])
		if in.ExitBranchElements == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v26, v27 := range in.ExitBranchElements {
				if v26 > 0 {
					out.RawByte(',')
				}
				easyjson44127895Encode5(out, v27)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}
func easyjson44127895Decode5(in *jlexer.Lexer, out *struct {
	Text string `json:"text"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "text":
			out.Text = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895Encode5(out *jwriter.Writer, in struct {
	Text string `json:"text"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"text\":"
		out.RawString(prefix[1:])
		out.String(string(in.Text))
	}
	out.RawByte('}')
}
func easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings4(in *jlexer.Lexer, out *Contour) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "time":
			out.Time = int(in.Int())
		case "color":
			out.Color = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings4(out *jwriter.Writer, in Contour) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Time != 0 {
		const prefix string = ",\"time\":"
		first = false
		out.RawString(prefix[1:])
		out.Int(int(in.Time))
	}
	if in.Color != "" {
		const prefix string = ",\"color\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Color))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Contour) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Contour) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson44127895EncodeGithubComLittlemonkeyltdValhallaGoBindings4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Contour) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Contour) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson44127895DecodeGithubComLittlemonkeyltdValhallaGoBindings4(l, v)
}
